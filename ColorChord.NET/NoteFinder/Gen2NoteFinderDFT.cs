#if !(STANDALONE_DFT_LIB)
using ColorChord.NET.API;
#endif
using System;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Runtime.Intrinsics;
using System.Runtime.Intrinsics.X86;
using System.Text;

namespace ColorChord.NET.NoteFinder;

/// <summary> A carefully optimized DFT implementation that creates clean and responsive data. </summary>
/// This implementation contains many quite particular choices, optimizations, and implementation details I worked on for years to fine-tune.
/// Data is provided through the standard mechanism in <see cref="Gen2NoteFinder.Cycle"/>. This data is processed in <see cref="AddAudioData(short[], uint)"/>,
/// which will periodically call <see cref="CalculateBins(uint)"/> to snapshot the state of the raw bins. It will also trigger any timing receivers that have
/// subscribed to periodic events. Then, when a visualizer or other output mechanism wants to use the data, it will call <see cref="Gen2NoteFinder.UpdateOutputs"/>
/// which in turn will call <see cref="CalculateOutput"/>. This will merge together all of the data that has been received since the last output cycle,
/// apply loudness correction, and format it into <see cref="AllBinValues"/> and <see cref="OctaveBinValues"/> for feature extraction in <see cref="Gen2NoteFinder.UpdateOutputs"/>.
public sealed class Gen2NoteFinderDFT
{
    private const bool ENABLE_SIMD = true;
    private const int MIN_WINDOW_SIZE = 16; // At 48KHz, scaled for other sample rates
    private const uint MAX_WINDOW_SIZE = 6144; // At 48KHz, scaled for other sample rates
    private const uint ABSOLUTE_MAX_WINDOW_SIZE = 32768; // Cannot exceed this regardless of sample rate, otherwise the accumulators may overflow
    private const uint USHORT_RANGE = ((uint)ushort.MaxValue) + 1;

    private const ushort SINE_TABLE_90_OFFSET = 8;
    private const ushort SINE_TABLE_90_OFFSET_SCALED = 8 << 11;
    private static readonly short[] SinWave = new short[] { 0, 799, 1567, 2275, 2896, 3405, 3783, 4016, 4095, 4016, 3783, 3405, 2896, 2275, 1567, 799 };

    public delegate void TimingReceiverCallback(uint samplesAdded);
    private readonly TimingReceiverCallback? TimingCallback;

    // Sine wave vectors generated by:
    /*
    const short AMPLITUDE = 4095;
    short[] Values = new short[16];
    for (byte Entry = 0; Entry < 16; Entry++) { Values[Entry] = (short)Math.Round(AMPLITUDE * Math.Sin(Entry * Math.Tau / 32)); }
    Console.WriteLine("private static readonly short[] SinWave = new short[] { " + string.Join(", ", Values) + " };");
    string UpperByteList = string.Join(", ", Values.Select(val => "0x" + (val >>   8).ToString("X2")));
    string LowerByteList = string.Join(", ", Values.Select(val => "0x" + (val & 0xFF).ToString("X2")));
    Console.WriteLine($"Vector256<byte> SinWaveVecUpperB = Vector256.Create((byte){UpperByteList}, {UpperByteList});");
    Console.WriteLine($"Vector256<byte> SinWaveVecLowerB = Vector256.Create((byte){LowerByteList}, {LowerByteList});");
    */

    /// <summary> The number of octaves to analyze. </summary>
    public uint OctaveCount { get; private init; }

    /// <summary> How many output bins should be calculated for each octave. </summary>
    public uint BinsPerOctave { get; private init; }

    /// <summary> How long our sample window is. </summary>
    public uint MaxPresentWindowSize { get; private init; } = 8192;

    /// <summary> The sample rate of the incoming audio signal, and our reference waveforms. </summary>
    /// <remarks> Use <see cref="UpdateSampleRate(uint)"/> to change this and trigger all needed internal changes. </remarks>
    public uint SampleRate { get; private init; }

    public float StartFrequency { get; private init; }

    /// <summary> The total number of bins over all octaves. </summary>
    public readonly ushort BinCount;

    /// <summary> Gets the index of the first bin in the topmost octave. </summary>
    private readonly ushort StartOfTopOctave;

    private readonly float StartFrequencyOfTopOctave;

    /// <summary> Where raw and resampled audio data is stored. </summary>
    /// <remarks> Size is [<see cref="MaxPresentWindowSize"/>] </remarks>
    private readonly short[] AudioBuffer;

    /// <summary> How large the audio buffer should be treated as being, for each bin. </summary>
    /// <remarks> Indexed by [Bin], size is [<see cref="BinCount"/>] </remarks>
    private readonly uint[] AudioBufferSizes;

    /// <summary> Up to where in the audio buffer data has been added to. </summary>
    private ushort AudioBufferAddHead;

    /// <summary> Where in the audio buffer each bin has removed data up to. </summary>
    /// <remarks> Indexed by [Bin], size is [<see cref="BinCount"/>] </remarks>
    private readonly ushort[] AudioBufferSubHeads;

    /// <summary> How far forward in the sine table this bin should step with every added sample, such that one full sine wave (wrap back to 0) occurs after the number of steps corresponding to the bin frequency. Format is fixed-point 5b+11b. </summary>
    /// <remarks> Indexed by [Bin], size is [<see cref="BinsPerOctave"/>] </remarks>
    private readonly DualU16[] SinTableStepSize;

    /// <summary>
    /// Where in the sin table the bin is currently at. This is incremented by <see cref="SinTableStepSize"/> every sample.
    /// Format is fixed-point 5b+11b.
    /// Since addition and subtraction of data does not happen in-phase, both are tracked separately.
    /// </summary>
    /// <remarks> Indexed by [Bin], size is [<see cref="BinCount"/>] </remarks>
    private readonly DualU16[] SinTableLocationAdd, SinTableLocationSub;

    /// <summary> Stores the current value of the sin*sample and cos*sample product sums, for each bin. </summary>
    /// <remarks> Used instead of <see cref="ProductAccumulators"/> on non-AVX2 systems. Indexed by [Bin], size is [<see cref="BinCount"/>] </remarks>
    private readonly DualI64[] SinProductAccumulators, CosProductAccumulators;

    /// <summary> Stores the current value of the sin*sample and cos*sample product sums, for each bin. Layout is [SinL, SinR, CosL, CosR]. </summary>
    /// <remarks> Used instead of (<see cref="SinProductAccumulators"/>, <see cref="CosProductAccumulators"/>) on AVX2-enabled systems. Indexed by [Bin], size is [<see cref="BinCount"/>] </remarks>
    private readonly Vector256<long>[] ProductAccumulators;

    private uint DataAddedSinceLastBinCalc = 0;

    private readonly float[] SmoothingFactors;
    private float MergedDataAmplitude = 0F;
    private readonly double[] MergedSinOutputs, MergedCosOutputs;
    private object MergedDataLockObj { get; init; } = new();

    /// <summary> The current calculated, scaled value for all DFT bins are stored. </summary>
    /// <remarks> Note that this is length <see cref="BinCount"/> + 2, as there's a padding value on both ends to make some operations nicer. </remarks>
    internal readonly float[] AllBinValues;

    /// <summary> The current scaled values of the DFT bins, with all octaves folded together. </summary>
    internal readonly float[] OctaveBinValues;

    public float LoudnessCorrectionAmount { get; private set; }

    private readonly float[] LoudnessCorrectionFactors;

    /// <summary> Stores the magnitude output of each bin before any filtering is done. </summary>
    /// <remarks> Indexed by [Bin], size is [<see cref="BinCount"/>] </remarks>
    public float[] RawBinMagnitudes { get; private init; }

    /// <summary> The frequency in Hz of each raw bin. </summary>
    /// <remarks> This isn't used in the main algorithm, only for pre-calculation of some data, and to present to the user. </remarks>
    public float[] RawBinFrequencies { get; init; }

    /// <summary> The range, in number of bins, of each bin's sensitivity to input signals. </summary>
    /// <remarks> A bin width of 2 would imply that this bin stops detecting anything in approximately the middle of the directly adjacent bin in both directions (a range of this bin's middle +/- 1.0 bins). </remarks>
    public float[] RawBinWidths { get; private init; }

    private int TEMP_CycleCount = 0;

    private float IIR_CONST = 0.85F; // TODO: Scale dynamically, lower => more older data

    /// <summary> Instantiates a Gen2DFT with the desired settings. </summary>
    /// <param name="octaveCount"> The number of octaves to analyze </param>
    /// <param name="binsPerOctave"> The number of output bins to calculate for each octave, must be a multiple of 4 </param>
    /// <param name="sampleRate"> The sample rate of the input audio signal </param>
    /// <param name="startFrequency"> The desired frequency of the lowest bin </param>
    /// <param name="loudnessCorrection"> The amount of human ear-modelled loudness correction to apply to the output bin values, between 0.0 and 1.0 </param>
    /// <param name="timingCallback"> A callback that will be dispatched at defined regular intervals during audio processing </param>
    public Gen2NoteFinderDFT(uint octaveCount, uint binsPerOctave, uint sampleRate, float startFrequency, float loudnessCorrection, TimingReceiverCallback? timingCallback) // TODO: Why are some properties while others not
    {
        this.OctaveCount = octaveCount;
        this.BinsPerOctave = binsPerOctave;
        this.SampleRate = sampleRate;
        this.StartFrequency = startFrequency;
        this.LoudnessCorrectionAmount = loudnessCorrection;
        this.TimingCallback = timingCallback;

        this.BinCount = (ushort)(OctaveCount * BinsPerOctave);
        this.StartOfTopOctave = (ushort)((OctaveCount - 1) * BinsPerOctave);
        this.StartFrequencyOfTopOctave = StartFrequency * MathF.Pow(2, OctaveCount - 1);

        AudioBufferSizes = new uint[BinCount];
        AudioBufferSubHeads = new ushort[BinCount];
        SinTableStepSize = new DualU16[BinCount];
        SinTableLocationAdd = new DualU16[BinCount];
        SinTableLocationSub = new DualU16[BinCount];
        SinProductAccumulators = new DualI64[BinCount];
        CosProductAccumulators = new DualI64[BinCount];
        ProductAccumulators = new Vector256<long>[BinCount];
        SmoothingFactors = new float[BinCount];
        MergedSinOutputs = new double[BinCount];
        MergedCosOutputs = new double[BinCount];
        AllBinValues = new float[BinCount + 2];
        OctaveBinValues = new float[(int)BinsPerOctave];
        LoudnessCorrectionFactors = new float[BinCount];
        RawBinMagnitudes = new float[BinCount];
        RawBinFrequencies = new float[BinCount];
        RawBinWidths = new float[BinCount];

        uint MaxAudioBufferSize = 0;
        for (uint Bin = 0; Bin < BinCount; Bin++)
        {
            float BinFrequency;
            uint ThisBufferSize;
            float ThisOctaveStart = StartFrequency * MathF.Pow(2, Bin / BinsPerOctave);
            BinFrequency = CalculateNoteFrequency(StartFrequency, BinsPerOctave, Bin);
            float NextBinFrequency = CalculateNoteFrequency(StartFrequency, BinsPerOctave, Bin + 2);
            //float IdealWindowSize = WindowSizeForBinWidth(TopOctaveNextBinFreq - TopOctaveBinFreq); // TODO: Add scale factor to shift this from no overlap to -3dB point
            ThisBufferSize = RoundedWindowSizeForBinWidth(NextBinFrequency - BinFrequency, BinFrequency, SampleRate);

            RawBinWidths[Bin] = MathF.Log2((BinFrequency + BinWidthAtWindowSize(ThisBufferSize, SampleRate)) / BinFrequency) * BinsPerOctave;

            AudioBufferSizes[Bin] = ThisBufferSize;
            RawBinFrequencies[Bin] = BinFrequency;
            MaxAudioBufferSize = Math.Max(MaxAudioBufferSize, ThisBufferSize);

            float NCOffset = SampleRate / (AudioBufferSizes[Bin] * 2F);
            float StepSizeNCL = USHORT_RANGE * (CalculateNoteFrequency(StartFrequency, BinsPerOctave, Bin) - NCOffset) / SampleRate;
            float StepSizeNCR = USHORT_RANGE * (CalculateNoteFrequency(StartFrequency, BinsPerOctave, Bin) + NCOffset) / SampleRate;
            SinTableStepSize[Bin].NCLeft = (ushort)Math.Round(StepSizeNCL);
            SinTableStepSize[Bin].NCRight = (ushort)Math.Round(StepSizeNCR);

            LoudnessCorrectionFactors[Bin] = LoudnessCorrectionAmount == 0F ? 1F : GetLoudnessCorrection(BinFrequency, LoudnessCorrectionAmount);
            SmoothingFactors[Bin] = MathF.Min(MathF.Max(0.1F, IIR_CONST - ((6000 - (int)ThisBufferSize) * 0.00008F)), IIR_CONST);
        }
        MaxPresentWindowSize = MaxAudioBufferSize;

        uint RealAudioBufferSize = MaxAudioBufferSize;
        if ((RealAudioBufferSize % 16) != 0) { RealAudioBufferSize = ((RealAudioBufferSize / 16) + 1) * 16; }
        RealAudioBufferSize += 16; // Add padding so SIMD operations can safely run off the end of the buffer, but this space will remain unused (not reported in MaxPresentWindowSize)
        AudioBuffer = new short[RealAudioBufferSize];

        for (uint Bin = 0; Bin < BinCount; Bin++)
        {
            AudioBufferSubHeads[Bin] = (ushort)((1 - AudioBufferSizes[Bin] + MaxAudioBufferSize) % MaxAudioBufferSize);
            SinTableLocationSub[Bin].NCLeft = (ushort)(-(SinTableStepSize[Bin].NCLeft * (AudioBufferSizes[Bin] - 1)));
            SinTableLocationSub[Bin].NCRight = (ushort)(-(SinTableStepSize[Bin].NCRight * (AudioBufferSizes[Bin] - 1)));
        }

#if !(STANDALONE_DFT_LIB)
        Log.Debug(nameof(Gen2NoteFinder) + " bin window lengths:");
        if (Log.EnableDebug)
        {
            for (int Octave = 0; Octave < OctaveCount; Octave++)
            {
                StringBuilder OctaveOutput = new();
                OctaveOutput.Append($"{RawBinFrequencies[Octave * BinsPerOctave]:F1}~{RawBinFrequencies[((Octave + 1) * BinsPerOctave) - 1]:F1}Hz: ");
                for (uint Bin = 0; Bin < BinsPerOctave; Bin++)
                {
                    OctaveOutput.Append(AudioBufferSizes[(Octave * BinsPerOctave) + Bin]);
                    OctaveOutput.Append(',');
                }
                Log.Debug(OctaveOutput.ToString());
            }
        }

#pragma warning disable CS0162 // Unreachable code detected
        if (!ENABLE_SIMD) { Log.Warn("SIMD has been compile-time disabled in this build. Expect significantly decreased efficiency."); }
#pragma warning restore CS0162 // Unreachable code detected
        if (!Avx2.IsSupported) { Log.Warn("Your CPU does not appear to support AVX2, this may lead to poor performance."); }
#else
        //Console.WriteLine("SSE? " + Sse.IsSupported);
        //Console.WriteLine("SSE2? " + Sse2.IsSupported);
        //Console.WriteLine("SSE4.2? " + Sse42.IsSupported);
        //Console.WriteLine("AVX? " + Avx.IsSupported);
        //Console.WriteLine("AVX2? " + Avx2.IsSupported);
#endif
    }

    /// <summary> Call whenever the sample rate of the input audio changes. Reconfigures the DFT to correctly run at the new sample rate. </summary>
    /// <param name="newSampleRate"> The new sample rate in Hz. If the sample rate is the same as the one already in use, nothing is done. </param>
    //public void UpdateSampleRate(uint newSampleRate)
    //{
    //    if (newSampleRate == SampleRate) { return; }
    //    SampleRate = newSampleRate;
    //    Reconfigure();
    //}

    /// <summary> Processes the given array of new audio data. </summary>
    /// <remarks> Automatically uses SIMD-accelerated code if applicable. </remarks>
    /// <param name="newData"> The data to process </param>
    public unsafe void AddAudioData(ReadOnlySpan<short> newData)
    {
        const int CALC_BIN_INTERVAL = 64;
        TEMP_CycleCount++;

        int Index = 0;
        if (Avx2.IsSupported && ENABLE_SIMD && newData.Length >= 16)
        {
            int EndIndex = newData.Length - 16;
            fixed (short* DataPtr = newData)
            {
                while (Index <= EndIndex)
                {
                    AddAudioData256(Vector256.Load(DataPtr + Index));
                    DataAddedSinceLastBinCalc += 16;
                    if (DataAddedSinceLastBinCalc >= CALC_BIN_INTERVAL) { CalculateBins(DataAddedSinceLastBinCalc); }
                    Index += 16;
                }
            }
        }
        while (Index < newData.Length)
        {
            AddAudioData(newData[Index++]);
            DataAddedSinceLastBinCalc++;
            if (DataAddedSinceLastBinCalc >= CALC_BIN_INTERVAL) { CalculateBins(DataAddedSinceLastBinCalc); }
        }

#if false
        const int CHECK_BIN = 96;
        if (TEMP_CycleCount % 50 == 0) { Console.WriteLine($"Bin magnitude {CHECK_BIN} ({RawBinFrequencies[CHECK_BIN]}Hz) is at {RawBinMagnitudes[CHECK_BIN]}."); }
#endif
    }

    /// <summary> Shifts in 16 samples of audio data, updating the sin and cos accumulators with their new values. </summary>
    /// <remarks> This assumes AVX2 support. Use <see cref="AddAudioData(short)"/> on systems that do not have AVX2 support, or for batches smaller than 16 samples. </remarks>
    /// <param name="newData"> The data to process </param>
    [MethodImpl(MethodImplOptions.NoInlining)] // I won't pretend to understand why, but ever since I made this a sealed non-static class (was static), this started getting inlined, and this results in about a 20% drop in performance.
    private void AddAudioData256(Vector256<short> newData)
    {
        Vector256<ushort> IncrementingFrom0 = Vector256.Create((ushort)0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15);
        Vector256<ushort> CosShift = Vector256.Create(SINE_TABLE_90_OFFSET_SCALED);

        ushort BinCount = this.BinCount;
        for (int Bin = 0; Bin < BinCount; Bin++)
        {
            Vector256<short> OldData;
            ushort SubHeadHere = this.AudioBufferSubHeads[Bin];

            if ((SubHeadHere + 16) <= this.MaxPresentWindowSize) { OldData = Vector256.LoadUnsafe(ref this.AudioBuffer[SubHeadHere]); }
            else { OldData = ReadArrayWraparound(this.AudioBuffer, this.MaxPresentWindowSize, SubHeadHere); }
            SubHeadHere = (ushort)((SubHeadHere + 16) % this.MaxPresentWindowSize);

            DualU16 SinTableStep = SinTableStepSize[Bin];
            Vector256<ushort> LeftSteps  = Avx2.MultiplyLow(Vector256.Create(SinTableStep.NCLeft ), IncrementingFrom0);
            Vector256<ushort> RightSteps = Avx2.MultiplyLow(Vector256.Create(SinTableStep.NCRight), IncrementingFrom0);

            Vector256<long> OldProducts;
            {
                DualU16 SinTableLocSub = SinTableLocationSub[Bin];
                Vector256<ushort> SinLocationsL = Avx2.Add(Vector256.Create(SinTableLocSub.NCLeft), LeftSteps);
                Vector256<ushort> SinLocationsR = Avx2.Add(Vector256.Create(SinTableLocSub.NCRight), RightSteps);

                Vector256<short> SinValuesL = GetSine256(SinLocationsL);
                Vector256<int> SinLCombined = Avx2.MultiplyAddAdjacent(SinValuesL, OldData);

                Vector256<short> SinValuesR = GetSine256(SinLocationsR);
                Vector256<int> SinRCombined = Avx2.MultiplyAddAdjacent(SinValuesR, OldData);

                Vector256<short> CosValuesL = GetSine256(Avx2.Add(SinLocationsL, CosShift));
                Vector256<int> CosLCombined = Avx2.MultiplyAddAdjacent(CosValuesL, OldData);

                Vector256<short> CosValuesR = GetSine256(Avx2.Add(SinLocationsR, CosShift)); // max 13b to prevent later overflow
                Vector256<int> CosRCombined = Avx2.MultiplyAddAdjacent(CosValuesR, OldData); // max 16b x 13b -> 29b + 29b -> 30b
                // None of the above 4 steps will overflow unless both audio data and sine value are -32768.

                Vector256<int> SinCombined = Avx2.HorizontalAdd(SinLCombined, SinRCombined); // Result: [SinL, SinL, SinR, SinR, SinL, SinL, SinR, SinR] max 30b + 30b -> 31b
                Vector256<int> CosCombined = Avx2.HorizontalAdd(CosLCombined, CosRCombined); // Result: [CosL, CosL, CosR, CosR, CosL, CosL, CosR, CosR] max 30b + 30b -> 31b
                Vector256<int> MixedCombined = Avx2.HorizontalAdd(SinCombined, CosCombined); // Result: [SinL, SinR, CosL, CosR, SinL, SinR, CosL, CosR] max 31b + 31b -> 32b
                OldProducts = Avx2.Add(Avx2.ConvertToVector256Int64(MixedCombined.GetLower()), Avx2.ConvertToVector256Int64(MixedCombined.GetUpper())); // Result: [SinL, SinR, CosL, CosR]
            }

            Vector256<long> NewProducts;
            {
                DualU16 SinTableLocAdd = SinTableLocationAdd[Bin];
                Vector256<ushort> SinLocationsL = Avx2.Add(Vector256.Create(SinTableLocAdd.NCLeft), LeftSteps);
                Vector256<ushort> SinLocationsR = Avx2.Add(Vector256.Create(SinTableLocAdd.NCRight), RightSteps);

                Vector256<short> SinValuesL = GetSine256(SinLocationsL);
                Vector256<int> SinLCombined = Avx2.MultiplyAddAdjacent(SinValuesL, newData);

                Vector256<short> SinValuesR = GetSine256(SinLocationsR);
                Vector256<int> SinRCombined = Avx2.MultiplyAddAdjacent(SinValuesR, newData);

                Vector256<short> CosValuesL = GetSine256(Avx2.Add(SinLocationsL, CosShift));
                Vector256<int> CosLCombined = Avx2.MultiplyAddAdjacent(CosValuesL, newData);

                Vector256<short> CosValuesR = GetSine256(Avx2.Add(SinLocationsR, CosShift));
                Vector256<int> CosRCombined = Avx2.MultiplyAddAdjacent(CosValuesR, newData);
                // None of the above 4 steps will overflow unless both audio data and sine value are -32768.

                Vector256<int> SinCombined = Avx2.HorizontalAdd(SinLCombined, SinRCombined); // Result: [SinL, SinL, SinR, SinR, SinL, SinL, SinR, SinR]
                Vector256<int> CosCombined = Avx2.HorizontalAdd(CosLCombined, CosRCombined); // Result: [CosL, CosL, CosR, CosR, CosL, CosL, CosR, CosR]
                Vector256<int> MixedCombined = Avx2.HorizontalAdd(SinCombined, CosCombined); // Result: [SinL, SinR, CosL, CosR, SinL, SinR, CosL, CosR]
                NewProducts = Avx2.Add(Avx2.ConvertToVector256Int64(MixedCombined.GetLower()), Avx2.ConvertToVector256Int64(MixedCombined.GetUpper())); // Result: [SinL, SinR, CosL, CosR]
            }

            Vector256<long> AccumulatorDeltas = Avx2.Subtract(NewProducts, OldProducts);
            this.ProductAccumulators[Bin] = Avx2.Add(this.ProductAccumulators[Bin], AccumulatorDeltas);

            this.AudioBufferSubHeads[Bin] = SubHeadHere;
            this.SinTableLocationSub[Bin].NCLeft  += (ushort)(SinTableStep.NCLeft  * 16);
            this.SinTableLocationSub[Bin].NCRight += (ushort)(SinTableStep.NCRight * 16);

            this.SinTableLocationAdd[Bin].NCLeft  += (ushort)(SinTableStep.NCLeft  * 16);
            this.SinTableLocationAdd[Bin].NCRight += (ushort)(SinTableStep.NCRight * 16);
        }

        ushort AddHead = this.AudioBufferAddHead;
        for (int i = 0; i < 16; i++)
        {
            this.AudioBuffer[AddHead] = newData[i];
            AddHead = (ushort)((AddHead + 1) % this.MaxPresentWindowSize);
        }
        this.AudioBufferAddHead = AddHead;
    }

    /// <summary> Grabs a Vector256 of data when the read location straddles the bounds of the underlying array of a circular buffer. </summary>
    /// <remarks> Only handles cases where data is needed from both the back and front of the buffer. Not usable for normal reads from within the buffer. </remarks>
    /// <param name="buffer"> The buffer to read from. </param>
    /// <param name="bufferEffLength"> The effective length of the buffer. In order to safely read from it, the buffer must be at least 16 x sizeof(short) larger than this. </param>
    /// <param name="readHead"> Where to start reading from. Must be within 15 elements of the end of the buffer's effective length. </param>
    /// <returns> A vector of data pulled from the end and beginning of the buffer, as if the array were circular wrapping at the effective length. </returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static Vector256<short> ReadArrayWraparound(short[] buffer, uint bufferEffLength, uint readHead)
    {
        Vector128<ushort> DecrementingTo0 = Vector128.Create((ushort)7, 6, 5, 4, 3, 2, 1, 0);
        Vector256<short> Result;
        Vector256<short> EndData = Vector256.LoadUnsafe(ref buffer[readHead]);
        Debug.Assert(readHead + 16U > bufferEffLength);
        ushort NumFromFront = (ushort)(readHead + 16U - bufferEffLength);
        Debug.Assert(NumFromFront < 16);

        if (NumFromFront < 8)
        {
            Vector128<short> FrontData = Vector128.LoadUnsafe(ref buffer[0]);
            Vector128<short> EndMask = Sse2.CompareGreaterThan(DecrementingTo0.AsInt16(), Vector128.Create((short)(NumFromFront - 1)));
            Vector128<short> EndMasked = Sse2.And(EndData.GetUpper(), EndMask);
            Vector128<short> FrontShifted = Sse2.ShiftLeftLogical128BitLane(FrontData.AsByte(), (byte)(16 - (NumFromFront * 2))).AsInt16();
            Vector128<short> Upper = Sse2.Or(FrontShifted, EndMasked);
            Result = Avx2.InsertVector128(EndData, Upper, 1);
        }
        else if (NumFromFront == 8) { Result = Avx2.InsertVector128(EndData, Vector128.LoadUnsafe(ref buffer[0]), 1); }
        else
        {
            Vector128<short> Upper = Vector128.LoadUnsafe(ref buffer[NumFromFront - 8]);
            Vector128<short> FrontData = Vector128.LoadUnsafe(ref buffer[0]);
            Vector128<short> EndMask = Sse2.CompareGreaterThan(DecrementingTo0.AsInt16(), Vector128.Create((short)(NumFromFront - 9)));
            Vector128<short> EndMasked = Sse2.And(EndData.GetLower(), EndMask);
            Vector128<short> FrontShifted = Sse2.ShiftLeftLogical128BitLane(FrontData.AsByte(), (byte)(32 - (NumFromFront * 2))).AsInt16();
            Vector128<short> Lower = Sse2.Or(EndMasked, FrontShifted);
            Result = Vector256.Create(Lower, Upper);
        }
        return Result;
    }

    /// <summary> Shifts in 1 sample of audio data, updating the sin and cos accumulators with their new values. </summary>
    /// <remarks> Requires no SIMD support. Use <see cref="AddAudioData256(Vector256{short})"/> on platforms with AVX2 support and data batches 16 samples or longer. </remarks>
    /// <param name="newData"> The data to process </param>
    private void AddAudioData(short newData)
    {
        ushort BinCount = this.BinCount;
        // Subtract old data from accumulators
        for (int Bin = 0; Bin < BinCount; Bin++)
        {
            // Find where we are in the sine table
            DualU16 SinTableLoc = this.SinTableLocationSub[Bin];
            DualI16 SinValue = GetSine(SinTableLoc, false);
            DualI16 CosValue = GetSine(SinTableLoc, true);

            // Multiply the outgoing sample by the correct sine sample
            short OldBufferData = this.AudioBuffer[this.AudioBufferSubHeads[Bin]];
            int OldSinProductNCL = SinValue.NCLeft  * OldBufferData;
            int OldSinProductNCR = SinValue.NCRight * OldBufferData;
            int OldCosProductNCL = CosValue.NCLeft  * OldBufferData;
            int OldCosProductNCR = CosValue.NCRight * OldBufferData;

            // Remove the product from the accumulators
            //ProductAccumulators[Bin] = ProductAccumulators[Bin] - Vector256.Create(OldSinProductNCL, OldSinProductNCR, OldCosProductNCL, OldCosProductNCR); // TODO: WTF? This just absolutely explodes sometimes???
            checked
            {
                Vector256<long> CurrentAccVal = this.ProductAccumulators[Bin]; // TODO: This does really weird things in release mode. Need to investigate!
                Vector256<long> NewAccVal = Vector256.Create(CurrentAccVal[0] - OldSinProductNCL, CurrentAccVal[1] - OldSinProductNCR, CurrentAccVal[2] - OldCosProductNCL, CurrentAccVal[3] - OldCosProductNCR);
                this.ProductAccumulators[Bin] = NewAccVal;
                this.SinProductAccumulators[Bin].NCLeft -= OldSinProductNCL;
                this.SinProductAccumulators[Bin].NCRight -= OldSinProductNCR;
                this.CosProductAccumulators[Bin].NCLeft -= OldCosProductNCL;
                this.CosProductAccumulators[Bin].NCRight -= OldCosProductNCR;
            }

            // Advance the buffer and sine table locations
            this.AudioBufferSubHeads[Bin] = (ushort)((this.AudioBufferSubHeads[Bin] + 1) % this.MaxPresentWindowSize);

            DualU16 SinTableStep = this.SinTableStepSize[Bin];
            this.SinTableLocationSub[Bin].NCLeft  += SinTableStep.NCLeft;
            this.SinTableLocationSub[Bin].NCRight += SinTableStep.NCRight;
        }

        // Write new data
        ushort HeadBefore = this.AudioBufferAddHead;
        this.AudioBuffer[HeadBefore] = newData;
        this.AudioBufferAddHead = (ushort)((HeadBefore + 1) % this.MaxPresentWindowSize);

        // Add new data to accumulators
        for (int Bin = 0; Bin < BinCount; Bin++)
        {
            // Find where we are in the sine table
            DualU16 SinTableLoc = this.SinTableLocationAdd[Bin];
            DualI16 SinValue = GetSine(SinTableLoc, false);
            DualI16 CosValue = GetSine(SinTableLoc, true);

            // Multiply the incoming sample by the correct sine sample
            int NewSinProductNCL = SinValue.NCLeft  * newData;
            int NewSinProductNCR = SinValue.NCRight * newData;
            int NewCosProductNCL = CosValue.NCLeft  * newData;
            int NewCosProductNCR = CosValue.NCRight * newData;

            // Add the product to the accumulators
            //ProductAccumulators[Bin] = ProductAccumulators[Bin] + Vector256.Create(NewSinProductNCL, NewSinProductNCR, NewCosProductNCL, NewCosProductNCR);
            checked
            {
                Vector256<long> CurrentAccVal = this.ProductAccumulators[Bin];
                Vector256<long> NewAccVal = Vector256.Create(CurrentAccVal[0] + NewSinProductNCL, CurrentAccVal[1] + NewSinProductNCR, CurrentAccVal[2] + NewCosProductNCL, CurrentAccVal[3] + NewCosProductNCR);
                this.ProductAccumulators[Bin] = NewAccVal;
                this.SinProductAccumulators[Bin].NCLeft += NewSinProductNCL;
                this.SinProductAccumulators[Bin].NCRight += NewSinProductNCR;
                this.CosProductAccumulators[Bin].NCLeft += NewCosProductNCL;
                this.CosProductAccumulators[Bin].NCRight += NewCosProductNCR;
            }

            // Advance the sine table locations
            DualU16 SinTableStep = this.SinTableStepSize[Bin];
            this.SinTableLocationAdd[Bin].NCLeft  += SinTableStep.NCLeft;
            this.SinTableLocationAdd[Bin].NCRight += SinTableStep.NCRight;
            //if (Bin == 191) { Debug.WriteLine($"{SinTableLoc.NCLeft},{SinTableLoc.NCRight},{SinValue.NCLeft},{SinValue.NCRight},{CosValue.NCLeft},{CosValue.NCRight},{NewSinProductNCL},{NewSinProductNCR},{NewCosProductNCL},{NewCosProductNCR}"); }
        }
    }

    /// <summary> Called from within the sample data processing code to periodically capture the DFT bin state and push it into <see cref="MergedSinOutputs"/> and <see cref="MergedCosOutputs"/>. Also triggers timing receivers if needed. </summary>
    /// <param name="samplesAdded"> The number of audio samples that have been processed since <see cref="CalculateBins(uint)"/> was last called. Used to trigger timing receivers if applicable. </param>
    private void CalculateBins(uint samplesAdded)
    {
        int BinCount = this.BinCount;
        Span<double> RotatedValues = stackalloc double[4 * 2];

        Debug.Assert(BinCount % 4 == 0, "BinCount needs to be a multiple of 4.");
        lock (this.MergedDataLockObj)
        {
            int BinIndex = 0;
            while (BinIndex < BinCount)
            {
                for (int SubIndex = 0; SubIndex < 4; SubIndex++)
                {
                    int InnerIndex = BinIndex + SubIndex;
                    Vector256<long> Products = this.ProductAccumulators[InnerIndex];
                    DualI16 SinVal = GetSine(this.SinTableLocationAdd[InnerIndex], false);
                    DualI16 CosVal = GetSine(this.SinTableLocationAdd[InnerIndex], true);

                    // Product accumulators are assumed to be up to 32768 32b values summed => 15b * 32b = 47b
                    long RotatedLSin = (Products[0] * CosVal.NCLeft) - (Products[2] * SinVal.NCLeft); // (47b * 16b) - (47b * 16b) = 64b
                    long RotatedLCos = (Products[0] * SinVal.NCLeft) + (Products[2] * CosVal.NCLeft);
                    long RotatedRSin = (Products[1] * CosVal.NCRight) - (Products[3] * SinVal.NCRight);
                    long RotatedRCos = (Products[1] * SinVal.NCRight) + (Products[3] * CosVal.NCRight);

                    long Sin = (RotatedLSin >> 32) * (RotatedRSin >> 32); // (64b >> 32) * (64b >> 32) = 64b
                    long Cos = (RotatedLCos >> 32) * (RotatedRCos >> 32);

                    RotatedValues[SubIndex] = Sin;
                    RotatedValues[SubIndex + 4] = Cos; // RotatedValues = {Sin[BinIndex:BinIndex+3], Cos[BinIndex:BinIndex+3]}

                    if (!(Avx2.IsSupported && ENABLE_SIMD))
                    {
                        this.MergedSinOutputs[InnerIndex] = this.MergedSinOutputs[InnerIndex] + Sin;
                        this.MergedCosOutputs[InnerIndex] = this.MergedCosOutputs[InnerIndex] + Cos;
                    }
                }

                if (Avx2.IsSupported && ENABLE_SIMD)
                {
                    Vector256<double> PreviousSinVals = Vector256.LoadUnsafe(ref this.MergedSinOutputs[BinIndex]);
                    Vector256<double> PreviousCosVals = Vector256.LoadUnsafe(ref this.MergedCosOutputs[BinIndex]);
                    Vector256<double> NewSinVals = Vector256.LoadUnsafe(ref RotatedValues[0]);
                    Vector256<double> NewCosVals = Vector256.LoadUnsafe(ref RotatedValues[4]);
                    Vector256<double> AddedSinVals = Avx.Add(PreviousSinVals, NewSinVals);
                    Vector256<double> AddedCosVals = Avx.Add(PreviousCosVals, NewCosVals);
                    AddedSinVals.StoreUnsafe(ref this.MergedSinOutputs[BinIndex]);
                    AddedCosVals.StoreUnsafe(ref this.MergedCosOutputs[BinIndex]);
                }

                BinIndex += 4;
            }
            this.MergedDataAmplitude += 1F;
        }

        this.TimingCallback?.Invoke(samplesAdded);
        this.DataAddedSinceLastBinCalc = 0;
    }

    public void CalculateOutput()
    {
        // TODO: Having this be called asynchronously from the data input code means that the responsiveness of any IIR we apply here depends on the frequency at which this is called.
        // Not sure if this is a real concern. Need to think a bit more about it.
        // This could be avoided by using MergedDataAmplitude to scale the IIR, but that's extra calculations
        if (this.MergedDataAmplitude == 0) { return; }
        int BinCount = this.BinCount;
        Debug.Assert(BinCount % 4 == 0, "BinCount needs to be a multiple of 4.");
        lock (this.MergedDataLockObj)
        {
            if (this.MergedDataAmplitude == 0) { return; } // This may have (and actually often does) happen if multiple outputs are present and operating on different threads.
            for (int Bin = 0; Bin < BinsPerOctave; Bin++) { this.OctaveBinValues[Bin] = 0; }

            int BinIndex = 0;
            if (Avx2.IsSupported && ENABLE_SIMD)
            {
                Vector256<double> AmplitudeScale = Vector256.Create((double)this.MergedDataAmplitude);
                while (BinIndex < BinCount)
                {
                    Vector256<double> MergedSinVals = Avx.Divide(Vector256.LoadUnsafe(ref this.MergedSinOutputs[BinIndex]), AmplitudeScale);
                    Vector256<double> MergedCosVals = Avx.Divide(Vector256.LoadUnsafe(ref this.MergedCosOutputs[BinIndex]), AmplitudeScale);

                    Vector256<double> SinCosSums = Vector256.Add(MergedSinVals, MergedCosVals);
                    Vector256<double> SinCosSumsNegated = Avx2.Xor(SinCosSums.AsUInt64(), Vector256.Create(0x8000_0000_0000_0000UL)).AsDouble();
                    Vector256<double> Magnitudes = Avx.Sqrt(Avx.Max(Vector256<double>.Zero, SinCosSumsNegated));

                    Vector256<double> WindowSizes = Avx.ConvertToVector256Double(Vector128.LoadUnsafe(ref this.AudioBufferSizes[BinIndex]).AsInt32());
                    Vector128<float> ScaledMagnitudes = Avx.ConvertToVector128Single(Avx.Divide(Avx.Sqrt(Avx.Divide(Magnitudes, WindowSizes)), Vector256.Create(3.0D))); // Scales such that a 0dB signal is approximately 1.0 // TODO: Check if this is still true

                    Vector128<float> IIRa = Vector128.LoadUnsafe(ref this.SmoothingFactors[BinIndex]);
                    Vector128<float> IIRb = Sse.Subtract(Vector128.Create(1F), IIRa);

                    Vector128<float> NewMagnitudes = Sse.Add(Sse.Multiply(Vector128.LoadUnsafe(ref this.RawBinMagnitudes[BinIndex]), IIRb), Sse.Multiply(ScaledMagnitudes, IIRa));
                    //ScaledMagnitudes.StoreUnsafe(ref RawBinMagnitudes[BinIndex]);
                    NewMagnitudes.StoreUnsafe(ref this.RawBinMagnitudes[BinIndex]);

                    Vector256<double>.Zero.StoreUnsafe(ref this.MergedSinOutputs[BinIndex]);
                    Vector256<double>.Zero.StoreUnsafe(ref this.MergedCosOutputs[BinIndex]);

                    BinIndex += 4;
                }
            }
            else
            {
                while (BinIndex < BinCount)
                {
                    double MergedSin = this.MergedSinOutputs[BinIndex] / this.MergedDataAmplitude;
                    double MergedCos = this.MergedCosOutputs[BinIndex] / this.MergedDataAmplitude;
                    double Magnitude = Math.Sqrt(Math.Max(0, -MergedSin - MergedCos));
                    uint WindowSize = this.AudioBufferSizes[BinIndex];
                    float ScaledMagnitude = (float)(Math.Sqrt(Magnitude / WindowSize) / 3.0D);
                    this.RawBinMagnitudes[BinIndex] = (this.RawBinMagnitudes[BinIndex] * (1F - this.IIR_CONST)) + (ScaledMagnitude * this.IIR_CONST);
                    this.MergedSinOutputs[BinIndex] = 0;
                    this.MergedCosOutputs[BinIndex] = 0;
                    BinIndex++;
                }
            }
            this.MergedDataAmplitude = 0F;
        }

        for (int Bin = 0; Bin < BinCount; Bin++)
        {
            float OutBinVal = this.RawBinMagnitudes[Bin] * this.LoudnessCorrectionFactors[Bin];
            this.OctaveBinValues[Bin % BinsPerOctave] += OutBinVal / this.OctaveCount;
            this.AllBinValues[Bin + 1] = MathF.Max(0, OutBinVal - 0.08F);
        }
    }

    /// <summary> Clears all data structures, resetting back to a state equivalent to not having received any data yet. </summary>
    public void Clear()
    {
        for (int i = 0; i < AudioBuffer.Length; i++) { AudioBuffer[i] = 0; }
        for (int i = 0; i < BinCount; i++)
        {
            SinProductAccumulators[i] = new();
            CosProductAccumulators[i] = new();
            ProductAccumulators[i] = Vector256<long>.Zero;
            MergedSinOutputs[i] = 0;
            MergedCosOutputs[i] = 0;
            AllBinValues[i + 1] = 0;
            RawBinMagnitudes[i] = 0;
        }
        for (int i = 0; i < BinsPerOctave; i++) { OctaveBinValues[i] = 0; }
    }

    /// <summary> Calculates the sine value of 2 positions </summary>
    /// <remarks> Does not require any SIMD support, however is significantly slower than <see cref="GetSine256(Vector256{ushort})"/> </remarks>
    /// <param name="sineTablePosition"> The wave positions, where one full sweep through possible values gives 1 full wavelength </param>
    /// <param name="shiftForCos"> Whether to offset both positions by 90 degrees to get a cosine value instead </param>
    /// <returns> The value of the sine wave at the given position pair </returns>
    public static DualI16 GetSine(DualU16 sineTablePosition, bool shiftForCos)
    {
        byte WholeLocationL = (byte)(((sineTablePosition.NCLeft  >> 11) + (shiftForCos ? SINE_TABLE_90_OFFSET : 0)) & 0b11111);
        byte WholeLocationR = (byte)(((sineTablePosition.NCRight >> 11) + (shiftForCos ? SINE_TABLE_90_OFFSET : 0)) & 0b11111);
        int LocationModifierL = (WholeLocationL << 27) >> 31;
        int LocationModifierR = (WholeLocationR << 27) >> 31;
        short ValueLowerL = (short)((SinWave[WholeLocationL & 0b1111] ^ LocationModifierL) - LocationModifierL); // The sine vector only contains the positive half of the wave, indices in the range 16...31 are just 0...15 but negative value
        short ValueLowerR = (short)((SinWave[WholeLocationR & 0b1111] ^ LocationModifierR) - LocationModifierR);

        byte AdjacentLocationL = (byte)((WholeLocationL + 1) & 0b11111);
        byte AdjacentLocationR = (byte)((WholeLocationR + 1) & 0b11111);
        int AdjLocationModifierL = (AdjacentLocationL << 27) >> 31;
        int AdjLocationModifierR = (AdjacentLocationR << 27) >> 31;
        short ValueUpperL = (short)((SinWave[AdjacentLocationL & 0b1111] ^ AdjLocationModifierL) - AdjLocationModifierL);
        short ValueUpperR = (short)((SinWave[AdjacentLocationR & 0b1111] ^ AdjLocationModifierR) - AdjLocationModifierR);

        short FractionalPartL = (short)((((ValueUpperL - ValueLowerL) << 8) * ((sineTablePosition.NCLeft  >> 3) & 0xFF)) >> 16); // Wasting the bottom 3 bits of position precision, but otherwise multiplication may overflow int
        short FractionalPartR = (short)((((ValueUpperR - ValueLowerR) << 8) * ((sineTablePosition.NCRight >> 3) & 0xFF)) >> 16);
        return new() { NCLeft = (short)(ValueLowerL + FractionalPartL), NCRight = (short)(ValueLowerR + FractionalPartR) };
    }

    /// <summary> Calculates the sine value of 16 positions </summary>
    /// <remarks> Requires AVX2 support, use <see cref="GetSine(DualU16, bool)"/> for systems without </remarks>
    /// <param name="positions"> Vector of sine wave positions, where one full sweep through possible values gives 1 full wavelength (i.e. 65536 = 2*pi) </param>
    /// <returns> Vector of the sine value, in range -4095 to +4095, for each location provided </returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Vector256<short> GetSine256(Vector256<ushort> positions) // input treated as sign.4.11 fixed-point number for table index
    {
        // See code at the top of this file for how these 2 are generated.
        Vector256<byte> SinWaveVecUpperB = Vector256.Create((byte)0x00, 0x03, 0x06, 0x08, 0x0B, 0x0D, 0x0E, 0x0F, 0x0F, 0x0F, 0x0E, 0x0D, 0x0B, 0x08, 0x06, 0x03, 0x00, 0x03, 0x06, 0x08, 0x0B, 0x0D, 0x0E, 0x0F, 0x0F, 0x0F, 0x0E, 0x0D, 0x0B, 0x08, 0x06, 0x03);
        Vector256<byte> SinWaveVecLowerB = Vector256.Create((byte)0x00, 0x1F, 0x1F, 0xE3, 0x50, 0x4D, 0xC7, 0xB0, 0xFF, 0xB0, 0xC7, 0x4D, 0x50, 0xE3, 0x1F, 0x1F, 0x00, 0x1F, 0x1F, 0xE3, 0x50, 0x4D, 0xC7, 0xB0, 0xFF, 0xB0, 0xC7, 0x4D, 0x50, 0xE3, 0x1F, 0x1F);

        Vector256<ushort> LocationsLeft = Avx2.ShiftRightLogical(positions, 11); // Between 0 and 31, shuffles map this as [0~31] => [0~15, 0~15]
        Vector256<ushort> LocationsRight = Avx2.Add(LocationsLeft, Vector256.Create((ushort)1)); // Between 1 and 32, but because the shuffles only look at the bottom 4 bits, is effectively mapped as [1~32] => [1~15, 0~15, 0]

        Vector256<byte> MixedLocations = Avx2.PackUnsignedSaturate(LocationsLeft.AsInt16(), LocationsRight.AsInt16()); // [LocationsLeft[0:7], LocationsRight[0:7], LocationsLeft[8:15], LocationsRight[8:15]]
        Vector256<byte> MixedSinValuesLower = Avx2.Shuffle(SinWaveVecLowerB, MixedLocations);
        Vector256<byte> MixedSinValuesUpper = Avx2.Shuffle(SinWaveVecUpperB, MixedLocations);

        Vector256<ushort> ValuesUnsignedLeft  = Avx2.UnpackLow (MixedSinValuesLower, MixedSinValuesUpper).AsUInt16();
        Vector256<ushort> ValuesUnsignedRight = Avx2.UnpackHigh(MixedSinValuesLower, MixedSinValuesUpper).AsUInt16();
        Vector256<short> ValuesLeft  = Avx2.Sign(ValuesUnsignedLeft.AsInt16(),  positions.AsInt16());
        Vector256<short> ValuesRight = Avx2.Sign(ValuesUnsignedRight.AsInt16(), Avx2.ShiftLeftLogical(LocationsRight, 11).AsInt16());

        Vector256<short> FractionalPositions = Avx2.ShiftRightLogical(Avx2.ShiftLeftLogical(positions, 5), 1).AsInt16(); // Since singed * unsigned isn't a thing, need to do (Positions << 5) to clear whole part of 5.11 fixed-point number, then >> 1 to prevent top bit from becoming sign.
        Vector256<short> ValueDiffs = Avx2.ShiftLeftLogical(Avx2.Subtract(ValuesRight, ValuesLeft), 1); // Then << 1 this one to compensate for the >> 1 above
        Vector256<short> FractionalValues = Avx2.MultiplyHigh(ValueDiffs, FractionalPositions); 

        Vector256<short> Values = Avx2.Add(ValuesLeft, FractionalValues);
        return Values;
    }

    public struct DualU16
    {
        public ushort NCLeft, NCRight;
        public override readonly string ToString() => $"2xU16 L={this.NCLeft}, R={this.NCRight}";
    }
    public struct DualI16
    {
        public short NCLeft, NCRight;
        public override readonly string ToString() => $"2xI16 L={this.NCLeft}, R={this.NCRight}";
    }
    public struct DualI64
    {
        public long NCLeft, NCRight;
        public override readonly string ToString() => $"2xI32 L={this.NCLeft}, R={this.NCRight}";
    }

    private static float BinWidthAtWindowSize(float windowSize, float sampleRate) => sampleRate / windowSize;
    private static float WindowSizeForBinWidth(float binWidth, float sampleRate) => sampleRate / binWidth;

    private static uint RoundedWindowSizeForBinWidth(float binWidth, float frequency, float sampleRate)
    {
        float IdealWindowSize = WindowSizeForBinWidth(binWidth, sampleRate);
        float PeriodInSamples = sampleRate / frequency;
        float PeriodsInWindow = IdealWindowSize / PeriodInSamples;
        float MaxWindowSizePeriods = MathF.Ceiling(MAX_WINDOW_SIZE * (sampleRate / 48000F) / PeriodInSamples);
        float MinWindowSizePeriods = MathF.Floor(MIN_WINDOW_SIZE * (sampleRate / 48000F) / PeriodInSamples);

        return (uint)Math.Min(ABSOLUTE_MAX_WINDOW_SIZE, MathF.Round((MathF.Max(MinWindowSizePeriods, MathF.Min(MaxWindowSizePeriods, MathF.Round(PeriodsInWindow))) * PeriodInSamples) + (PeriodInSamples * 0.5F)));
    }

    private static float CalculateNoteFrequency(float octaveStart, uint binsPerOctave, uint binIndex) => octaveStart * GetNoteFrequencyMultiplier(binsPerOctave, binIndex);
    private static float GetNoteFrequencyMultiplier(uint binsPerOctave, uint binIndex) => MathF.Pow(2F, (float)binIndex / binsPerOctave);

    /// <summary> Gets a factor to multiply the output amplitude by to correct for percieved loudness. </summary>
    /// <remarks> Output is based on ISO 226:2023 data, and assumes a fixed loudness, and that the item being multiplied is sqrt(dB level). </remarks>
    /// <param name="frequency"> The frequency of the bin to get correction factor for </param>
    /// <param name="correctionAmount"> The strength, between 0.0~1.0 to apply the correction, applied to logarithmic amplitude. Generally, 0.25~0.33 yields good results. </param>
    /// <returns> Scaling factor between 0.0~1.0 for the given frequency </returns>
    private static float GetLoudnessCorrection(float frequency, float correctionAmount)
    {
        const float LOUDNESS = 50F; // in phon
        ReadOnlySpan<float> Frequencies = new float[] { 20F,    25F,    31.5F,  40F,    50F,    63F,    80F,    100F,   125F,   160F,   200F,   250F,   315F,   400F,  500F,  630F,   800F,   1000F, 1250F,  1600F,  2000F, 2500F, 3150F,  4000F,  5000F,  6300F,  8000F,  10000F, 12500F };
        ReadOnlySpan<float> af = new float[]          { 0.635F, 0.602F, 0.569F, 0.537F, 0.509F, 0.482F, 0.456F, 0.433F, 0.412F, 0.391F, 0.373F, 0.357F, 0.343F, 0.33F, 0.32F, 0.311F, 0.303F, 0.3F,  0.295F, 0.292F, 0.29F, 0.29F, 0.289F, 0.289F, 0.289F, 0.293F, 0.303F, 0.323F, 0.354F };
        ReadOnlySpan<float> LU = new float[]          { -31.5F, -27.2F, -23.1F, -19.3F, -16.1F, -13.1F, -10.4F, -8.2F,  -6.3F,  -4.6F,  -3.2F,  -2.1F,  -1.2F,  -0.5F, 0F,    0.4F,   0.5F,   0F,    -2.7F,  -4.2F,  -1.2F, 1.4F,  2.3F,   1F,     -2.3F,  -7.2F,  -11.2F, -10.9F, -3.5F };
        ReadOnlySpan<float> Tf = new float[]          { 78.1F,  68.7F,  59.5F,  51.1F,  44F,    37.5F,  31.5F,  26.5F,  22.1F,  17.9F,  14.4F,  11.4F,  8.6F,   6.2F,  4.4F,  3F,     2.2F,   2.4F,  3.5F,   1.7F,   -1.3F, -4.2F, -6F,    -5.4F,  -1.5F,  6F,     12.6F,  13.9F,  12.3F };

        int IndexLower = 0, IndexUpper = 0;
        if (frequency < Frequencies[^1])
        {
            for (int i = 0; i < Frequencies.Length; i++)
            {
                if (Frequencies[i] > frequency)
                {
                    IndexUpper = i;
                    IndexLower = Math.Max(0, i - 1);
                    break;
                }
            }
        }
        else
        {
            IndexUpper = Frequencies.Length - 1;
            IndexLower = Frequencies.Length - 1;
        }
        float dBAtLower = (10F / af[IndexLower] * MathF.Log10((MathF.Pow(4E-10F, 0.3F - af[IndexLower]) * (MathF.Pow(10F, 0.03F * LOUDNESS) - MathF.Pow(10F, 0.072F))) + MathF.Pow(10F, af[IndexLower] * (Tf[IndexLower] + LU[IndexLower]) / 10F))) - LU[IndexLower];
        float dBAtUpper = (10F / af[IndexUpper] * MathF.Log10((MathF.Pow(4E-10F, 0.3F - af[IndexUpper]) * (MathF.Pow(10F, 0.03F * LOUDNESS) - MathF.Pow(10F, 0.072F))) + MathF.Pow(10F, af[IndexUpper] * (Tf[IndexUpper] + LU[IndexUpper]) / 10F))) - LU[IndexUpper];
        // This just uses linear interpolation, and incorrectly assumes dB and frequency scale linearly. However, the error caused by these bad assumptions should be minimal, and I can't be bothered to implement a more complex correct version.
        // Remember, this is a visualization, not a scientific tool :)
        float InnerPosition = (IndexUpper == IndexLower) ? 0F : (frequency - Frequencies[IndexLower]) / (Frequencies[IndexUpper] - Frequencies[IndexLower]);
        Debug.Assert(InnerPosition <= 1F);
        Debug.Assert(InnerPosition >= 0F);
        float dBAtFreq = (dBAtUpper * InnerPosition) + (dBAtLower * (1F - InnerPosition));
        // Since the amplitude has its sqrt taken a second time, dB = (20 * log_10(amplitude)) * 2
        // As such, to get a scaling factor we need to divide the exponent by 20 * 2 instead of just 20
        return MathF.Pow(10F, (LOUDNESS - dBAtFreq) * correctionAmount / 40F);
    }
}
